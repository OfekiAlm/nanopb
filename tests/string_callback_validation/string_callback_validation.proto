/*
 * Comprehensive string validation test proto
 * 
 * Tests all string validation rules across different allocation modes:
 * - Regular string with (nanopb).max_size
 * - Repeated string with (nanopb).max_count
 * - Callback string with (nanopb).type = FT_CALLBACK
 * - Repeated callback string
 * 
 * Covers all string validation rules:
 * - Pattern: PREFIX, SUFFIX, CONTAINS, ASCII
 * - Format: EMAIL, HOSTNAME, IP, IPV4, IPV6
 * - Set membership: IN, NOT_IN
 */

syntax = "proto3";

import "validate.proto";
import "nanopb.proto";

option (validate.validate) = true;

/* ===========================================================================
 * REGULAR STRING TESTS (static allocation with max_size)
 * ===========================================================================*/

/* Test PREFIX rule on regular string */
message RegularStringPrefix {
    string value = 1 [(nanopb).max_size = 64, (validate.rules).string.prefix = "PREFIX_"];
}

/* Test SUFFIX rule on regular string */
message RegularStringSuffix {
    string value = 1 [(nanopb).max_size = 64, (validate.rules).string.suffix = "_SUFFIX"];
}

/* Test CONTAINS rule on regular string */
message RegularStringContains {
    string value = 1 [(nanopb).max_size = 64, (validate.rules).string.contains = "@"];
}

/* Test ASCII rule on regular string */
message RegularStringAscii {
    string value = 1 [(nanopb).max_size = 64, (validate.rules).string.ascii = true];
}

/* Test EMAIL rule on regular string */
message RegularStringEmail {
    string value = 1 [(nanopb).max_size = 128, (validate.rules).string.email = true];
}

/* Test HOSTNAME rule on regular string */
message RegularStringHostname {
    string value = 1 [(nanopb).max_size = 128, (validate.rules).string.hostname = true];
}

/* Test IP rule on regular string */
message RegularStringIp {
    string value = 1 [(nanopb).max_size = 46, (validate.rules).string.ip = true];
}

/* Test IPV4 rule on regular string */
message RegularStringIpv4 {
    string value = 1 [(nanopb).max_size = 16, (validate.rules).string.ipv4 = true];
}

/* Test IPV6 rule on regular string */
message RegularStringIpv6 {
    string value = 1 [(nanopb).max_size = 46, (validate.rules).string.ipv6 = true];
}

/* Test IN rule on regular string */
message RegularStringIn {
    string value = 1 [
        (nanopb).max_size = 32, 
        (validate.rules).string.in = "red",
        (validate.rules).string.in = "green", 
        (validate.rules).string.in = "blue"
    ];
}

/* Test NOT_IN rule on regular string */
message RegularStringNotIn {
    string value = 1 [
        (nanopb).max_size = 32, 
        (validate.rules).string.not_in = "FORBIDDEN",
        (validate.rules).string.not_in = "BLOCKED", 
        (validate.rules).string.not_in = "BANNED"
    ];
}

/* ===========================================================================
 * REPEATED STRING TESTS (static allocation with max_count)
 * ===========================================================================*/

/* Test PREFIX rule on repeated string */
message RepeatedStringPrefix {
    repeated string values = 1 [(nanopb).max_size = 64, (nanopb).max_count = 5, (validate.rules).repeated.items.string.prefix = "PREFIX_"];
}

/* Test SUFFIX rule on repeated string */
message RepeatedStringSuffix {
    repeated string values = 1 [(nanopb).max_size = 64, (nanopb).max_count = 5, (validate.rules).repeated.items.string.suffix = "_SUFFIX"];
}

/* Test CONTAINS rule on repeated string */
message RepeatedStringContains {
    repeated string values = 1 [(nanopb).max_size = 64, (nanopb).max_count = 5, (validate.rules).repeated.items.string.contains = "@"];
}

/* Test ASCII rule on repeated string */
message RepeatedStringAscii {
    repeated string values = 1 [(nanopb).max_size = 64, (nanopb).max_count = 5, (validate.rules).repeated.items.string.ascii = true];
}

/* ===========================================================================
 * ENVELOPE MESSAGE (root message for filter_udp)
 * 
 * Contains test cases for regular and repeated strings.
 * 
 * Note: Callback string content-based validation (PREFIX, SUFFIX, CONTAINS, etc.)
 * requires the callback context in nanopb_generator.py to store the string data
 * pointer. Currently only MIN_LEN/MAX_LEN rules work for callback strings because
 * only the field_length is stored in the callback context.
 * See the callback_validation test for MIN_LEN/MAX_LEN callback string validation.
 * ===========================================================================*/

message StringValidationEnvelope {
    /* Regular strings - statically allocated with max_size */
    string regular_prefix = 1 [(nanopb).max_size = 64, (validate.rules).string.prefix = "PREFIX_"];
    string regular_suffix = 2 [(nanopb).max_size = 64, (validate.rules).string.suffix = "_SUFFIX"];
    string regular_contains = 3 [(nanopb).max_size = 64, (validate.rules).string.contains = "@"];
    string regular_ascii = 4 [(nanopb).max_size = 64, (validate.rules).string.ascii = true];
    string regular_email = 5 [(nanopb).max_size = 128, (validate.rules).string.email = true];
    string regular_hostname = 6 [(nanopb).max_size = 128, (validate.rules).string.hostname = true];
    string regular_ip = 7 [(nanopb).max_size = 46, (validate.rules).string.ip = true];
    string regular_in = 8 [(nanopb).max_size = 32, (validate.rules).string.in = "red", (validate.rules).string.in = "green", (validate.rules).string.in = "blue"];
    string regular_not_in = 9 [(nanopb).max_size = 32, (validate.rules).string.not_in = "FORBIDDEN", (validate.rules).string.not_in = "BLOCKED"];
    
    /* Repeated strings - statically allocated arrays with max_count */
    repeated string repeated_prefix = 10 [(nanopb).max_size = 64, (nanopb).max_count = 5, (validate.rules).repeated.items.string.prefix = "PREFIX_"];
    repeated string repeated_contains = 11 [(nanopb).max_size = 64, (nanopb).max_count = 5, (validate.rules).repeated.items.string.contains = "@"];
}
