syntax = "proto3";

import "nanopb.proto";
import "validate.proto";

// Nested message type for callback testing
message NestedItem {
    int32 item_id = 1 [(validate.rules).int32 = {gt: 0}];
    string item_name = 2 [(nanopb).max_length = 50, (validate.rules).string = {min_len: 1, max_len: 50}];
}

// Message with callback fields for testing
message CallbackTestMessage {
    // Repeated submessage as callback (most common case)
    repeated NestedItem items = 1 [(nanopb).type = FT_CALLBACK];
    
    // String as callback
    string callback_string = 2 [(nanopb).type = FT_CALLBACK, (validate.rules).string = {min_len: 5, max_len: 100}];
    
    // Bytes as callback  
    bytes callback_bytes = 3 [(nanopb).type = FT_CALLBACK, (validate.rules).bytes = {min_len: 1, max_len: 256}];
    
    // A static field for comparison
    int32 static_field = 4 [(validate.rules).int32 = {gte: 0, lte: 1000}];
}

// Simple top-level message for root-message mode testing
message RootMessage {
    int32 root_id = 1 [(validate.rules).int32 = {gt: 0}];
    repeated NestedItem nested_items = 2 [(nanopb).type = FT_CALLBACK];
    string name = 3 [(nanopb).max_length = 100, (validate.rules).string = {min_len: 1, max_len: 100}];
    // Callback string field for testing string validation during decode
    string callback_description = 4 [(nanopb).type = FT_CALLBACK, (validate.rules).string = {min_len: 10, max_len: 200}];
    
    // ============================================================
    // Callback string fields with CONTENT-BASED validation rules
    // These test PREFIX, SUFFIX, CONTAINS, ASCII, EMAIL, IN, NOT_IN
    // All are FT_CALLBACK - decoded content stored in callback_ctx
    // ============================================================
    
    // PREFIX rule - callback string must start with "PREFIX_"
    string callback_prefix = 5 [(nanopb).type = FT_CALLBACK, (validate.rules).string.prefix = "PREFIX_"];
    
    // SUFFIX rule - callback string must end with "_SUFFIX"
    string callback_suffix = 6 [(nanopb).type = FT_CALLBACK, (validate.rules).string.suffix = "_SUFFIX"];
    
    // CONTAINS rule - callback string must contain "@"
    string callback_contains = 7 [(nanopb).type = FT_CALLBACK, (validate.rules).string.contains = "@"];
    
    // ASCII rule - callback string must be ASCII only
    string callback_ascii = 8 [(nanopb).type = FT_CALLBACK, (validate.rules).string.ascii = true];
    
    // EMAIL rule - callback string must be valid email format
    string callback_email = 9 [(nanopb).type = FT_CALLBACK, (validate.rules).string.email = true];
    
    // IN rule - callback string must be one of allowed values
    string callback_in = 10 [(nanopb).type = FT_CALLBACK, 
        (validate.rules).string.in = "red",
        (validate.rules).string.in = "green", 
        (validate.rules).string.in = "blue"];
    
    // NOT_IN rule - callback string must not be a forbidden value
    string callback_not_in = 11 [(nanopb).type = FT_CALLBACK,
        (validate.rules).string.not_in = "FORBIDDEN",
        (validate.rules).string.not_in = "BLOCKED"];
}
